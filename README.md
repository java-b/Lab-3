# Lab ３

> 目标：巩固 String 类和 Math 类的知识

## Lab 2 疑难杂症： `equals` VS `==`

下面的语句何时为 `true`，何时为 `false`？体会 `euqals` 和 `==` 的相似和差异。

```java
"5".equals('5')
'5'.equals('5')
"5"=='5'
```

## 消息加密与破解

异或符号 `^` 的运算方法如下：

```
1 ^ 1 = 0
0 ^ 0 = 0
1 ^ 0 = 1
0 ^ 1 = 1
```

简而言之：`两数不同，结果为１；两数相同，结果为０`。

我们注意到如下规律（式子中的数字为二进制）：

```
100 ^ 111 = 011
011 ^ 111 = 100
011 ^ 100 = 111
```

更普遍地，如果 `a ^ b = c`，那么 `c ^ b = a`。

利用这个规律，我们设计一个极为 **naive** 的消息加密与破解工具。

假设消息为 `msg`，密码为 `pw`，我们对 `msg` 与 `pw` 进行异或操作：

`encoded = msg ^ pw`

此时，`encoded` 就是加密的结果，还原成消息的方法就是：

`msg = endcoded ^ pw`

对于给定的消息，我们通过 **消息与密码进行异或操作得到密文** ，掌握密码的人可以通过 **密文与密码的异或操作得到原文**，其实 **加密与解密是同一个操作**。

要求大家设计一个加密/解密工具，尝试个位数的密码（密码为0-9），还原以下密文：
```
}kq$ckp$mp
```

**提示　1**
助教生成这段密文的加密过程如下：

- 给定某个神秘的字符串 `String msg = <不能告诉你>`
- 设置一个 **个位数** 的密码 `int pw = <猜猜看啊>`
- **依次** 取出 `String msg` 中的每个字符，与 `int pw` 进行异或操作，得到一个新的字符 `char en`
- 把 **所有的新字符** 拼接在一起，得到密文 `}kq$ckp$mp`

*思考*：原来的消息由多少位字符构成？

**提示 ２**
在 `提示 1` 中，我们提到，消息 `msg` 是 `String`，密码是 `pw` 是 `int`，而异或操作的两个数字都必须是 `int`，怎么办呢？

事实上，`String` 是由 `char` 组成的，而 `char` 类型和 `int` 类型可以互相转换，依据是 `ASCII` 码表。其中，`Dec` 列是 `int` 值，`Chr` 列是 `char` 值，如图：

![](http://www.asciitable.com/index/asciifull.gif)

由图可见：

- `char` 类型的 `A` 对应 `int` 类型的 `65`
- `char` 类型的 `0` 对应 `int` 类型的 `48` 

**提示 3**
如何将 `char` 类型、`int` 类型转换为字符串？用法如下：
```java
new String(65)=="65"          // 这是把 int 转换为 String
new String((char)65)=="A"     // 这是先把 int 转换为 char，再把 char 转换为 String
new String('A'+65)=="130"     // 这是先进行 'A' 与 65 的整数加减法，得到 130，再把数字 130 转换成 String
new String("A"+65)=="A65"     // 这是先进行 "A" 与 65 的字符串拼接操作，直接得到字符串 "A65"
new String(""+'A'+65)=="A65"  // 这是先进行 "" 与　'A' 的字符串拼接操作得到"A"，再进行 "A" 与 65 的字符串拼接操作，得到字符串 "A65"
new String('A'+65+"")=="130"  // 这是先进行 'A' 与　65 的加法操作得到１３０，再进行 １３０ 与 "" 的字符串拼接操作，得到字符串 "130"
```
`+` 符号有两个注意点：
- 它既可以作为 `字符串拼接` 的操作,也可以作为 `算数加法` 的操作。
  - 当且仅当操作数含有字符串时，就是字符串拼接操作，否则为加法操作。
  - 字符串拼接的结果是字符串
- 运算顺序是从左到右

